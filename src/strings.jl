
# `Typstry`

"""
    Mode

An `Enum`erated type used to specify that the current Typst syntactical
context is [`code`](@ref), [`markup`](@ref), or [`math`](@ref).

```jldoctest
julia> Mode
Enum Mode:
code = 0
markup = 1
math = 2
```
"""
@enum Mode code markup math

"""
    Typst{T}
    Typst(::T)

A wrapper used to pass values to
[`show(::IO,\u00A0::MIME"text/typst",\u00A0::Typst)`](@ref).

```jldoctest
julia> Typst(1)
Typst{Int64}(1)

julia> Typst("a")
Typst{String}("a")
```
"""
struct Typst{T}
    value::T
end

"""
    TypstString <: AbstractString
    TypstString(::Any; context...)

Convert the value to a Typst formatted string.

Optional Julia settings and Typst parameters are passed to
[`show(::IO,\u00A0::MIME"text/typst",\u00A0::Typst)`](@ref)
in an `IOContext`. See also [`show_typst`](@ref) for a list of supported types.

!!! info
    This type implements the `String` interface.
    However, the interface is unspecified, which may result in unexpected behavior.

# Examples
```jldoctest
julia> TypstString("a")
typst"\\\"a\\\""

julia> TypstString("a"; mode = code)
typst"\\\"\\\\\\"a\\\\\\"\\\""
```
"""
struct TypstString <: AbstractString
    text::String

    TypstString(x; context...) =
        new(sprint(show, typst_mime, maybe_wrap(x); context = (context...,)))
end

TypstString(x::TypstString; context...) = x

"""
    TypstText{T}
    TypstText(::Any)

A wrapper whose [`show_typst`](@ref) method uses `print`.

!!! info
    This may be used to insert control characters into a [`TypstString`](@ref).
    Unescaped control characters in `TypstString`s may
    break formatting in some environments, such as the REPL.

# Examples
```jldoctest
julia> TypstText(1)
TypstText{Int64}(1)

julia> TypstText("a")
TypstText{String}("a")
```
"""
struct TypstText{T}
    value::T
end

"""
    @typst_str(s)
    typst"s"

Construct a [`TypstString`](@ref).

Control characters are escaped,
except double quotation marks and backslashes in the same manner as `@raw_str`.
Values may be interpolated by calling the `TypstString` constructor,
except using a backslash instead of the type name.

!!! tip
    Print directly to an `IO` using
    [`show(::IO,\u00A0::MIME"text/typst",\u00A0::Typst)`](@ref).

    See also the performance tip to [Avoid string interpolation for I/O]
    (https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-string-interpolation-for-I/O).

# Examples
```jldoctest
julia> x = 1;

julia> typst"\$ \\(x) / \\(x + 1) \$"
typst"\$ 1 / 2 \$"

julia> typst"\\(x // 2)"
typst"\$1 / 2\$"

julia> typst"\\(x // 2; mode = math)"
typst"(1 / 2)"

julia> typst"\\\\(x)"
typst"\\\\(x)"
```
"""
macro typst_str(s)
    _s = Expr(:string)
    args = _s.args
    filename = __source__.file
    previous = current = firstindex(s)
    last = lastindex(s)

    while (regex_match = match(r"(?<!\\)\\\(", s, current)) !== nothing
        current = prevind(s, regex_match.offset)
        start = current + 2
        previous <= current && push!(args, s[previous:current])
        current = static_parse(s, start; filename, greedy = false)[2]
        previous = current
        push!(args, esc(static_parse("TypstString" * s[start: current - 1]; filename)))
    end

    previous <= last && push!(args, s[previous:last])
    :(TypstString(TypstText($_s)))
end

# Internals

"""
    preamble

A constant used at the beginning of Typst source files generated by
[`show(::IO,\u00A0::Union{MIME"application/pdf",\u00A0MIME"image/png",\u00A0MIME"image/svg+xml"},\u00A0::TypstString)`](@ref).

# Examples
```jldoctest
julia> println(Typstry.preamble)
#set page(margin: 1em, height: auto, width: auto, fill: white)
#set text(16pt, font: "JuliaMono")
```
"""
const preamble = """
#set page(margin: 1em, height: auto, width: auto, fill: white)
#set text(16pt, font: "JuliaMono")
"""

"""
    typst_mime

# Examples
```jldoctest
julia> Typstry.typst_mime
MIME type text/typst
```
"""
const typst_mime = MIME"text/typst"()

"""
    block(io)

Return `io[:block]::Bool`.

# Examples
```jldoctest
julia> Typstry.block(IOContext(stdout, :block => true))
true
```
"""
block(io) = io[:block]::Bool

"""
    code_mode(io)

Print the number sign, unless `mode(io) == code`.

# See also [`Mode`](@ref) and [`mode`](@ref Typstry.mode).

# Examples
```jldoctest
julia> Typstry.code_mode(IOContext(stdout, :mode => code))

julia> Typstry.code_mode(IOContext(stdout, :mode => markup))
#

julia> Typstry.code_mode(IOContext(stdout, :mode => math))
#
```
"""
code_mode(io) = if mode(io) != code print(io, "#") end

"""
    depth(io)

Return `io[:depth]::Int`.

# Examples
```jldoctest
julia> Typstry.depth(IOContext(stdout, :depth => 0))
0
```
"""
depth(io) = io[:depth]::Int

"""
    enclose(f, io, x, left, right = reverse(left); kwargs...)

Call `f(io,\u00A0x;\u00A0kwargs...)` between printing `left` and `right`, respectfully.

# Examples
```jldoctest
julia> Typstry.enclose((io, i; x) -> print(io, i, x), stdout, 1, "\\\$ "; x = "x")
\$ 1x \$
```
"""
function enclose(f, io, x, left, right = reverse(left); context...)
    print(io, left)
    f(io, x; context...)
    print(io, right)
end

"""
    format(::Union{MIME"application/pdf", MIME"image/png", MIME"image/svg+xml"})

# Examples
```jldoctest
julia> Typstry.format(MIME"application/pdf"())
"pdf"

julia> Typstry.format(MIME"image/png"())
"png"

julia> Typstry.format(MIME"image/svg+xml"())
"svg"
```
"""
format(::MIME"application/pdf") = "pdf"
format(::MIME"image/png") = "png"
format(::MIME"image/svg+xml") = "svg"

"""
    indent(io)

Return `io[:indent]::String`.

# Examples
```jldoctest
julia> Typstry.indent(IOContext(stdout, :indent => ' ' ^ 4))
"    "
```
"""
indent(io) = io[:indent]::String

"""
    join_with(f, io, xs, delimeter; kwargs...)

Similar to `join`, except printing with `f(io, x; kwargs...)`.

# Examples
```jldoctest
julia> Typstry.join_with((io, i; x) -> print(io, -i, x), stdout, 1:4, ", "; x = "x")
-1x, -2x, -3x, -4x
```
"""
function join_with(f, io, xs, delimeter; kwargs...)
    _xs = Stateful(xs)

    for x in _xs
        f(io, x; kwargs...)
        isempty(_xs) || print(io, delimeter)
    end
end

"""
    math_pad(io, x)

Return `""`, `"\\\$"`, or `"\\\$ "` depending on the
[`block`](@ref Typstry.block) and [`mode`](@ref Typstry.mode) settings.

# Examples
```jldoctest
julia> Typstry.math_pad(IOContext(stdout, :mode => math))
""

julia> Typstry.math_pad(IOContext(stdout, :block => true, :mode => markup))
"\\\$ "

julia> Typstry.math_pad(IOContext(stdout, :block => false, :mode => markup))
"\\\$"
```
"""
math_pad(io) =
    if mode(io) == math ""
    else block(io) ? "\$ " : "\$"
    end

"""
    mode(io)

Return `io[:mode]::Mode`.

See also [`Mode`](@ref).

# Examples
```jldoctest
julia> Typstry.mode(IOContext(stdout, :mode => code))
code::Mode = 0
```
"""
mode(io) = io[:mode]::Mode

"""
    maybe_wrap(::Any)

Wrap the value in [`Typst`](@ref) unless it is a [`TypstString`](@ref) or [`TypstText`](@ref).

# Examples
```jldoctest
julia> Typstry.maybe_wrap(1)
Typst{Int64}(1)

julia> Typstry.maybe_wrap(TypstString(1))
typst"1"

julia> Typstry.maybe_wrap(TypstText(1))
TypstText{Int64}(1)
```
"""
maybe_wrap(x::Union{TypstString, TypstText}) = x
maybe_wrap(x) = Typst(x)

"""
    parenthesize(io)

Return `io[:parenthesize]::Bool`.

# Examples
```jldoctest
julia> Typstry.parenthesize(IOContext(stdout, :parenthesize => true))
true
```
"""
parenthesize(io) = io[:parenthesize]::Bool

"""
    print_parameters(io, f, keys)

Print the name of a Typst function, an opening parenthesis,
the parameters to a Typst function, and a newline.

Skip `keys` that are not in the `IOContext`.

# Examples
```jldoctest
julia> Typstry.print_parameters(
           IOContext(stdout, :delim => "\\\"(\\\""),
       "vec", [:delim, :gap])
vec(delim: "(",
```
"""
function print_parameters(io, f, keys)
    print(io, f, "(")

    for key in keys
        value = get(io, key, "")::String
        isempty(value) || print(io, key, ": ", value, ", ")
    end

    println(io)
end

"""
    print_quoted(io, s)

Print the string [`enclose`](@ref Typstry.enclose)d in double
quotation marks and with interior double quotations marks escaped.

# Examples
```jldoctest
julia> Typstry.print_quoted(stdout, TypstString("a"))
"\\\"a\\\""
```
"""
print_quoted(io, s) = enclose(escape_raw_string, io, s, "\"")

"""
    show_array(io, x)
"""
show_array(io, x) = enclose(io, x, "(", ")") do io, x
    join_with(_show_typst, io, x, ", ")
    length(x) == 1 && print(io, ",")
end

"""
    show_raw(io, x)
"""
function show_raw(f, io, x, language)
    _block = block(io)

    mode(io) == math && print(io, "#")
    print(io, "```", language, _block ? "\n" : " ")
    f(io, x)
    _block && println(io)
    print(io, "```")
end


"""
    show_vector(io, x)
"""
show_vector(io, x) = enclose(io, x, math_pad(io)) do io, x
    _depth, _indent = depth(io), indent(io)
    __depth = _depth + 1

    print_parameters(io, "vec", [:delim, :gap])
    print(io, _indent ^ __depth)
    join_with(_show_typst, IOContext(io, :depth => __depth, :mode => math), x, ", "),
    print(io, "\n", _indent ^ _depth, ")")
end

"""
    static_parse(args...; filename, kwargs...)

Call `Meta.parse` with the `filename` if it is supported
in the current Julia version (at least v1.10).
"""
static_parse(args...; filename, kwargs...) =
    @static VERSION < v"1.10" ? parse(args...; kwargs...) : parse(args...; filename, kwargs...)

# `Typstry`

@doc """
    code

A Typst syntactical [`Mode`](@ref) prefixed by the number sign.

# Examples
```jldoctest
julia> code
code::Mode = 0
```
""" code

@doc """
    markup

A Typst syntactical [`Mode`](@ref) at the top-level of source text and enclosed within square brackets.

```jldoctest
julia> markup
markup::Mode = 1
```
""" markup


@doc """
    math

A Typst syntactical [`Mode`](@ref) enclosed within dollar signs.

```jldoctest
julia> math
math::Mode = 2
```
""" math

"""
    context(x)

Provide formatting data for
[`show(::IO,\u00A0::MIME"text/typst",\u00A0::Typst)`](@ref).

Implement this function for a custom type to specify its custom settings and parameters.
Passing a value wrapped in [`Typst`](@ref) will `merge!` its custom context with defaults,
such that the defaults may be overwritten.
To be compatible with merging contexts and constructing an `IOContext`,
methods must return an `AbstractDict{Symbol}`.

| Key             | Default                  | Type           | Description                                                                                                                                                                       |
|:----------------|:-------------------------|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `:block`        | `false`                  | `Bool`         | When `:mode => math`, specifies whether the enclosing dollar signs are padded with a space to render the element inline or its own block.                                         |
| `:depth`        | `0`                      | `Int`          | The current level of nesting within container types to specify the degree of indentation.                                                                                         |
| `:indent`       | `'\u00A0'\u00A0^\u00A04` | `String`       | The string used for horizontal spacing by some elements with multi-line Typst formatting.                                                                                         |
| `:mode`         | `markup`                 | [`Mode`](@ref) | The current Typst syntactical context where `code` follows the number sign, `markup` is at the top-level and enclosed in square brackets, and `math` is enclosed in dollar signs. |
| `:parenthesize` | `true`                   | `Bool`         | Whether to enclose some mathematical elements in parentheses to specify their operator precedence and avoid ambiguity.                                                            |
"""
context(x::Typst) = merge!(Dict(
    :block => false,
    :depth => 0,
    :indent => "    ",
    :mode => markup,
    :parenthesize => true
), context(x.value))
context(x) = Dict{Symbol, Union{}}()

_show_typst(io, x) = show(io, typst_mime, Typst(x))

"""
    show_typst(x)

Print to `stdout` in Typst format with the default and custom [`context`](@ref)s.

# Examples
```jldoctest
julia> show_typst(1 // 2)
\$1 / 2\$

julia> show_typst(1:4)
\$vec(
    1, 2, 3, 4
)\$
```
"""
show_typst(x) = _show_typst(stdout, x)

"""
    show_typst(io, x)

Print in Typst format with Julia settings and Typst parameters provided by an `IOContext`.

Implement this function for a custom type to specify its Typst formatting.
Settings are used in Julia to format the [`TypstString`](@ref).
Parameters are passed to a function in the Typst source file and have the same name as in Typst,
except that dashes are replaced with underscores.

For additional information on settings and parameters, see also [`context`](@ref)
and the [Typst Documentation](https://typst.app/docs/), respectively.

!!! info
    Some types, particularly containers, may call
    [`show(::IO,\u00A0::MIME"text/typst",\u00A0::Typst)`](@ref)
    to format a value, which may use additional settings and parameters.

!!! warning
    This function's methods are incomplete.
    Please file an issue or create a pull-request for missing methods.

| Type                                                      | Settings                     | Parameters                                                        |
|:----------------------------------------------------------|:-----------------------------|:------------------------------------------------------------------|
| `Docs.HTML`                                               | `:mode`                      | `:block`                                                          |
| `Docs.Text`                                               | `:mode`                      |                                                                   |
| `AbstractArray`                                           | `:depth`, `:indent`, `:mode` | `:block`, `:delim`, `:gap`                                        |
| `AbstractChar`                                            | `:mode`                      |                                                                   |
| `AbstractFloat`                                           |                              |                                                                   |
| `AbstractMatrix`                                          | `:depth`, `:indent`, `:mode` | `:augment`, `:block`, `:column_gap`, `:delim`, `:gap`, `:row_gap` |
| `AbstractString`                                          | `:mode`                      |                                                                   |
| `Bool`                                                    | `:mode`                      |                                                                   |
| `Complex{Bool}`                                           | `:mode`, `:parenthesize`     | `:block`                                                          |
| `Complex`                                                 | `:mode`, `:parenthesize`     | `:block`                                                          |
| `Irrational`                                              | `:mode`                      |                                                                   |
| `Nothing`                                                 | `:mode`                      |                                                                   |
| `OrdinalRange{<:Integer,\u00A0<:Integer}`                 | `:mode`                      |                                                                   |
| `Rational`                                                | `:mode`, `:parenthesize`     | `:block`                                                          |
| `Regex`                                                   | `:mode`                      |                                                                   |
| `Signed`                                                  |                              |                                                                   |
| `StepRangeLen{<:Integer,\u00A0<:Integer,\u00A0<:Integer}` | `:mode`                      |                                                                   |
| `String`                                                  | `:mode`                      |                                                                   |
| `Tuple`                                                   | `:depth`, `:indent`, `:mode` | `:block`, `:delim`, `:gap`                                        |
| `Typst`                                                   |                              |                                                                   |
| `TypstString`                                             |                              |                                                                   |
| `TypstText`                                               |                              |                                                                   |
| `Unsigned`                                                | `:mode`                      |                                                                   |

# Examples
```jldoctest
julia> show_typst(stdout, 1)
1

julia> show_typst(IOContext(stdout, :mode => code), "a")
"\\\"a\\\""
```
"""
show_typst(io, x::AbstractChar) = mode(io) == code ?
    enclose(show, io, x, "\"") :
    show(io, x)
show_typst(io, x::AbstractMatrix) = mode(io) == code ?
    show_array(io, x) :
    enclose((io, x; indent, depth) -> begin
        _depth = depth + 1

        print_parameters(io, "mat", [:augment, :column_gap, :delim, :gap, :row_gap])
        join_with((io, x; indent) -> begin
            print(io, indent ^ _depth)
            join_with(_show_typst, io, x, ", ")
        end, IOContext(io, :depth => _depth, :mode => math), eachrow(x), ";\n"; indent)
        print(io, "\n", indent ^ depth, ")")
    end, IOContext(io, :parenthesize => false), x, math_pad(io); indent = indent(io), depth = depth(io))
show_typst(io, x::AbstractString) = show_typst(io, Text(x))
function show_typst(io, x::Bool)
    _mode = mode(io)

    _mode == markup && print(io, "#")
    _mode == math ? enclose(print, io, x, "\"") : print(io, x)
end
show_typst(io, x::Complex{Bool}) = show_typst(io, Complex(Int(real(x)), Int(imag(x))))
show_typst(io, x::Complex) = enclose(io, x, math_pad(io)) do io, x
    enclose(IOContext(io, :mode => math, :parenthesize => false), x,
        (mode(io) == math && parenthesize(io) ? ("(", ")") : ("", ""))...) do io, x
        imaginary = imag(x)
        _real, _imaginary = real(x), abs(imaginary)
        __real, __imaginary = _real == 0, _imaginary == 0
        ___imaginary = signbit(imaginary)

        __real && !__imaginary || _show_typst(io, _real)

        if _imaginary != 0
            if !__real enclose(print, io, ___imaginary ? "-" : "+", " ")
            elseif ___imaginary print(io, "-")
            end

            _imaginary == 1 || _show_typst(io, abs(imaginary))
            print(io, "i")
        end
    end
end
show_typst(io, x::HTML) = show_raw((io, x) -> show(io, MIME"text/html"(), x), io, x, "html")
show_typst(io, x::Irrational) =
    mode(io) == code ? _show_typst(io, Float64(x)) : print(io, x)
function show_typst(io, ::Nothing)
    code_mode(io)
    print(io, "none")
end
function show_typst(io, x::Rational)
    _mode = mode(io)
    f = (io, x) -> enclose(io, x, (parenthesize(io) ? ("(", ")") : ("", ""))...) do io, x
        _show_typst(io, numerator(x))
        print(io, " / ")
        _show_typst(io, denominator(x))
    end

    _mode == markup ?
        enclose(f, IOContext(io, :mode => math, :parenthesize => false), x, block(io) ? "\$ " : "\$") :
        f(io, x)
end
function show_typst(io, x::Regex)
    code_mode(io)
    enclose(io, x, "regex(", ")") do io, x
        buffer = IOBuffer()

        print(buffer, x)
        seek(buffer, 1)

        for c in readeach(buffer, Char)
            print(io, c)
        end
    end
end
function show_typst(io, x::Text) # TODO: remove allocation
    s = string(x)
    mode(io) == markup ? show(io, escape_string(s, "\"\$")) : print_quoted(io, repr(s))
end
show_typst(io, x::Typst) = show_typst(io, x.value)
show_typst(io, x::TypstText) = print(io, x.value)
function show_typst(io, x::Unsigned)
    code_mode(io)
    show(io, x)
end
function show_typst(io, x::Union{AbstractArray, Tuple})
    io = IOContext(io, :parenthesize => false)
    mode(io) == code ? show_array(io, x) : show_vector(io, x)
end
show_typst(io, x::Union{AbstractFloat, Signed, TypstString}) = print(io, x)
show_typst(io, x::Union{
    OrdinalRange{<:Integer, <:Integer},
    StepRangeLen{<:Integer, <:Integer, <:Integer}
}) = mode(io) == code ?
    enclose(io, x, "range(", ")") do io, x
        _step = step(x)

        _show_typst(io, first(x))
        print(io, ", ")
        _show_typst(io, last(x) + 1)
        if _step != 1
            print(io, ", step: ")
            _show_typst(io, _step)
        end
    end :
    show_vector(io, x)

# `Base`

"""
    IOBuffer(::TypstString)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> IOBuffer(typst"a")
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1, maxsize=Inf, ptr=1, mark=-1)
```
"""
IOBuffer(ts::TypstString) = IOBuffer(ts.text)

"""
    codeunit(::TypstString)
    codeunit(::TypstString, ::Integer)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> codeunit(typst"a")
UInt8

julia> codeunit(typst"a", 1)
0x61
```
"""
codeunit(ts::TypstString) = codeunit(ts.text)
codeunit(ts::TypstString, i::Integer) = codeunit(ts.text, i)

"""
    isvalid(::TypstString, ::Integer)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> isvalid(typst"a", 1)
true
```
"""
isvalid(ts::TypstString, i::Integer) = isvalid(ts.text, i::Integer)

"""
    iterate(::TypstString, ::Integer)
    iterate(::TypstString)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> iterate(typst"a")
('a', 2)

julia> iterate(typst"a", 1)
('a', 2)
```
"""
iterate(ts::TypstString) = iterate(ts.text)
iterate(ts::TypstString, i::Integer) = iterate(ts.text, i)

"""
    ncodeunits(::TypstString)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> ncodeunits(typst"a")
1
```
"""
ncodeunits(ts::TypstString) = ncodeunits(ts.text)

"""
    pointer(::TypstString)

See also [`TypstString`](@ref).
"""
pointer(ts::TypstString) = pointer(ts.text)

"""
    repr(::MIME, ::TypstString; kwargs...)

See also [`TypstString`](@ref).

!!! info
    This method patches incorrect output from the assumption in `repr`
    that the parameter is already in the requested `MIME` type when
    the `MIME` type `istextmime` and the parameter is an `AbstractString`.

# Examples
```jldoctest
julia> repr("text/plain", typst"a")
"typst\\\"a\\\""

julia> repr("text/typst", typst"a")
typst"a"
```
"""
repr(::MIME"text/typst", ts::TypstString; kwargs...) = ts
repr(m::MIME, ts::TypstString; kwargs...) = sprint(show, m, ts; kwargs...)

"""
    show(::IO, ::TypstString)

See also [`TypstString`](@ref).

# Examples
```jldoctest
julia> show(stdout, typst"a")
typst"a"
```
"""
function show(io::IO, ts::TypstString)
    print(io, "typst")
    print_quoted(io, ts.text)
end

"""
    show(::IO, ::MIME"text/typst", ::Union{Typst, TypstString, TypstText})

Print the [`Typst`](@ref) format.

This method provides formatting data to [`show_typst`](@ref)
specified by a default and custom [`context`](@ref).

See also [`TypstString`](@ref) and [`TypstText`](@ref).

# Examples
```jldoctest
julia> show(stdout, "text/typst", typst"a")
a

julia> show(stdout, "text/typst", Typst("a"))
"a"

julia> show(IOContext(stdout, :mode => code), "text/typst", Typst("a"))
"\\\"a\\\""
```
"""
show(io::IO, m::MIME"text/typst", t::Typst) = show(IOContext(io), m, t)
function show(io::IOContext, ::MIME"text/typst", t::Typst)
    for (k, v) in context(t)
        io = IOContext(io, k => get(io, k, v))
    end

    show_typst(io, t)
end
show(io::IO, ::MIME"text/typst", t::Union{TypstString, TypstText}) = show_typst(io, t)

"""
    show(::IO, ::Union{
        MIME"application/pdf", MIME"image/png", MIME"image/svg+xml"
    }, ::TypstString)

Print the Portable Document Format (PDF), Portable Network Graphics (PNG),
or Scalable Vector Graphics (SVG) format.

The `preamble` keyword parameter used by [`render`](@ref) may be specified in an `IOContext`.

!!! note
    Environments, such as Pluto.jl notebooks,
    may use these methods to `display` a [`TypstString`](@ref).
"""
function show(io::IO, m::Union{
    MIME"application/pdf", MIME"image/png", MIME"image/svg+xml"
}, ts::TypstString)
    input = tempname()
    output = tempname * "." * format(m)

    render(ts; input, output, open = false, preamble = get(io, :preamble, preamble)::String)
    print(io, read(output, String))
end

"""
    examples

A constant `Vector` of Julia values and their corresponding
`Type`s implemented for [`show_typst`](@ref).
"""
const examples = [
    html"<p>a</p>" => Docs.HTML,
    text"[\"a\"]" => Docs.Text,
    [true, 1, Any[1.2, 1 // 2]] => AbstractArray,
    'a' => AbstractChar,
    1.2 => AbstractFloat,
    Any[true 1; 1.2 1 // 2] => AbstractMatrix,
    "a" => AbstractString,
    true => Bool,
    im => Complex{Bool},
    1 + 2im => Complex,
    Ï€ => Irrational,
    nothing => Nothing,
    0:2:6 => OrdinalRange{<:Integer, <:Integer},
    1 // 2 => Rational,
    r"[a-z]" => Regex,
    1 => Signed,
    StepRangeLen(0, 2, 4) => StepRangeLen{<:Integer, <:Integer, <:Integer},
    (true, 1, 1.2, 1 // 2) => Tuple,
    Typst(1) => Typst,
    typst"[\"a\"]" => TypstString,
    TypstText([1, 2, 3, 4]) => TypstText,
    0xff => Unsigned
]
